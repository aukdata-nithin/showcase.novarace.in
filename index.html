<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NovaRace ‚Äì Race Frame Studio</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link
        href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=DM+Sans:ital,wght@0,300;0,400;0,500;0,700;1,300&display=swap"
        rel="stylesheet">
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link rel="stylesheet" href="styles.css">

</head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-LX2WTH1ZWY"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-LX2WTH1ZWY');
</script>

<body>
    <div class="grain"></div>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback } = React;

        // ‚îÄ‚îÄ‚îÄ Mock Events ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const EVENTS = [
            {
                id: "evt001", slug: "bangalore-ultra-2025", name: "Bangalore Ultra 2025", date: "Feb 23, 2025", hashTag: "#BangaloreUltra2025",
                frames: [
                    { id: "f1", name: "Finisher", src: "assets/bangalore-ultra-2025/frame_1.svg" },
                    { id: "f2", name: "10K Glory", src: "assets/bangalore-ultra-2025/frame_2.svg" },
                    { id: "f3", name: "Half Hero", src: "assets/bangalore-ultra-2025/frame_3.svg" },
                    { id: "f4", name: "Full Beast", src: "assets/bangalore-ultra-2025/frame_4.svg" },
                ]
            },
            {
                id: "evt002", slug: "sivagiri-marathon-2025", name: "Sivagiri Marathon 2025", date: "Mar 15, 2025", hashTag: "#SivagiriMarathon2025",
                frames: [
                    { id: "f5", name: "5K Spark", src: "assets/sivagiri-marathon-2025/frame_5.svg" },
                    { id: "f6", name: "10K Rise", src: "assets/sivagiri-marathon-2025/frame_6.svg" },
                ]
            },
            {
                id: "evt003", slug: "sooriya-saree-walkathon-2026", name: "Sooriya Saree Walkathon 2026", date: "Mar 15, 2025", hashTag: "I'm participating in the Sooriya Saree Walkathon 2026, Nellai \nü•ª Registrations are open ‚Äî join with me!\nüëâ https://www.novarace.in/events/sooriya-saree-walkathon-2026\n\n#nellaimarathon #SooriyaSareeWalkathon2026\n",
                frames: [
                    { id: "f7", name: "", src: "assets/sooriya-saree-walkathon-2026/Nellai_Marathon_transparent.png" },
                ]
            },
        ];

        const DEFAULT_PS = { offX: 0, offY: 0, scale: 1.0, brightness: 100 };

        // ‚îÄ‚îÄ‚îÄ Draw frame overlay on a canvas context ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        function drawFrameOverlay(ctx, S, frame, img) {
            if (img) ctx.drawImage(img, 0, 0, S, S);

            // Name band
            const bh = S * 0.1;
            ctx.fillStyle = "#fff";
            ctx.font = `bold ${Math.round(S * 0.045)}px 'Bebas Neue',sans-serif`;
            ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.fillText(frame.name.toUpperCase(), S / 2, S - bh / 2);
            ctx.textAlign = "left"; ctx.textBaseline = "alphabetic";
        }

        // ‚îÄ‚îÄ‚îÄ Frame thumbnail ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // ‚îÄ‚îÄ‚îÄ Frame thumbnail ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        function FrameThumb({ frame, selected, onClick }) {
            const ref = useRef(null);
            useEffect(() => {
                const cv = ref.current; if (!cv) return;
                const ctx = cv.getContext("2d"), S = cv.width;

                const img = new Image();
                img.onload = () => {
                    ctx.clearRect(0, 0, S, S);
                    ctx.fillStyle = "#1a1a1a"; ctx.fillRect(0, 0, S, S);
                    ctx.fillStyle = "#333";
                    ctx.beginPath(); ctx.arc(S / 2, S * 0.38, S * 0.18, 0, Math.PI * 2); ctx.fill();
                    ctx.fillRect(S * 0.26, S * 0.56, S * 0.48, S * 0.38);
                    drawFrameOverlay(ctx, S, frame, img);
                };
                img.src = frame.src;
            }, [frame]);
            return (
                <div className={`frame-thumb ${selected ? "selected" : ""}`} onClick={onClick}>
                    <canvas ref={ref} width={200} height={200} />
                    <div className="frame-label">{frame.name}</div>
                </div>
            );
        }

        // ‚îÄ‚îÄ‚îÄ Studio Canvas: renders photo + frame, handles drag + pinch ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        function StudioCanvas({ photo, frame, ps, onDrag, editMode, canvasRef }) {
            const wrapRef = useRef(null);
            const activeRef = useRef(null); // { startX, startY, startOffX, startOffY }
            const pinchRef = useRef(null); // { dist, startScale }
            const rafRef = useRef(null);

            const [frameImg, setFrameImg] = useState(null);
            useEffect(() => {
                if (!frame) { setFrameImg(null); return; }
                const i = new Image();
                i.onload = () => setFrameImg(i);
                i.src = frame.src;
            }, [frame]);

            // ‚îÄ‚îÄ Render ‚îÄ‚îÄ
            useEffect(() => {
                const cv = canvasRef.current; if (!cv) return;
                const ctx = cv.getContext("2d");
                const S = cv.width;
                ctx.clearRect(0, 0, S, S);

                const renderFrame = () => { if (frame) drawFrameOverlay(ctx, S, frame, frameImg); };

                if (!photo) {
                    ctx.fillStyle = "#0d0d0d"; ctx.fillRect(0, 0, S, S);
                    ctx.fillStyle = "#1c1c1c";
                    ctx.beginPath(); ctx.arc(S / 2, S * 0.40, S * 0.11, 0, Math.PI * 2); ctx.fill();
                    ctx.fillRect(S * 0.34, S * 0.52, S * 0.32, S * 0.22);
                    ctx.fillStyle = "#2a2a2a";
                    ctx.font = `${S * 0.03}px 'DM Sans',sans-serif`;
                    ctx.textAlign = "center";
                    ctx.fillText("Upload your photo to begin", S / 2, S * 0.72);
                    ctx.textAlign = "left";
                    renderFrame(); return;
                }

                const img = new Image();
                img.onload = () => {
                    ctx.save();
                    ctx.filter = `brightness(${ps.brightness}%)`;
                    const ir = img.width / img.height;
                    let bw, bh;
                    if (ir > 1) { bh = S * ps.scale; bw = bh * ir; }
                    else { bw = S * ps.scale; bh = bw / ir; }
                    ctx.drawImage(img, (S - bw) / 2 + ps.offX, (S - bh) / 2 + ps.offY, bw, bh);
                    ctx.restore();
                    renderFrame();
                };
                img.src = photo;
            }, [photo, frame, ps, frameImg]);

            // ‚îÄ‚îÄ Pointer helpers ‚îÄ‚îÄ
            const clientToCanvas = useCallback((clientX, clientY) => {
                // Return delta multiplier: canvas_px per display_px
                const wrap = wrapRef.current;
                if (!wrap) return { ratio: 1 };
                return { ratio: (canvasRef.current?.width || 1000) / wrap.offsetWidth, x: clientX, y: clientY };
            }, [canvasRef]);

            // Mouse events
            const onMouseDown = useCallback((e) => {
                if (!photo || editMode !== "move") return;
                e.preventDefault();
                const { ratio } = clientToCanvas(e.clientX, e.clientY);
                activeRef.current = { x: e.clientX, y: e.clientY, ox: ps.offX, oy: ps.offY, ratio };
                wrapRef.current?.classList.add("is-moving");
            }, [photo, editMode, ps.offX, ps.offY, clientToCanvas]);

            const onMouseMove = useCallback((e) => {
                if (!activeRef.current) return;
                const { x, y, ox, oy, ratio } = activeRef.current;
                onDrag(ox + (e.clientX - x) * ratio, oy + (e.clientY - y) * ratio);
            }, [onDrag]);

            const onMouseUp = useCallback(() => {
                activeRef.current = null;
                wrapRef.current?.classList.remove("is-moving");
            }, []);

            // Touch events
            const onTouchStart = useCallback((e) => {
                e.preventDefault();
                if (e.touches.length === 2) {
                    // Pinch
                    activeRef.current = null;
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    pinchRef.current = { dist: Math.hypot(dx, dy), startScale: ps.scale };
                } else if (editMode === "move" && photo) {
                    // Drag
                    const { ratio } = clientToCanvas(e.touches[0].clientX, e.touches[0].clientY);
                    activeRef.current = { x: e.touches[0].clientX, y: e.touches[0].clientY, ox: ps.offX, oy: ps.offY, ratio };
                    wrapRef.current?.classList.add("is-moving");
                }
            }, [photo, editMode, ps.offX, ps.offY, ps.scale, clientToCanvas]);

            const onTouchMove = useCallback((e) => {
                e.preventDefault();
                if (e.touches.length === 2 && pinchRef.current) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const newDist = Math.hypot(dx, dy);
                    const newScale = Math.min(4, Math.max(0.4, pinchRef.current.startScale * (newDist / pinchRef.current.dist)));
                    onDrag(ps.offX, ps.offY, parseFloat(newScale.toFixed(3)));
                } else if (activeRef.current && e.touches.length === 1) {
                    const { x, y, ox, oy, ratio } = activeRef.current;
                    onDrag(ox + (e.touches[0].clientX - x) * ratio, oy + (e.touches[0].clientY - y) * ratio);
                }
            }, [onDrag, ps]);

            const onTouchEnd = useCallback(() => {
                activeRef.current = null;
                pinchRef.current = null;
                wrapRef.current?.classList.remove("is-moving");
            }, []);

            const wrapCls = `canvas-wrap${!photo ? "" : editMode === "move" ? " can-move" : ""}`;

            return (
                <div
                    ref={wrapRef}
                    className={wrapCls}
                    onMouseDown={onMouseDown}
                    onMouseMove={onMouseMove}
                    onMouseUp={onMouseUp}
                    onMouseLeave={onMouseUp}
                    onTouchStart={onTouchStart}
                    onTouchMove={onTouchMove}
                    onTouchEnd={onTouchEnd}
                >
                    <canvas ref={canvasRef} width={1000} height={1000} />
                    <div className="canvas-hint">‚úã Drag to reposition ¬∑ Pinch to zoom</div>
                </div>
            );
        }

        // ‚îÄ‚îÄ‚îÄ Camera Modal ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        function CameraModal({ onCapture, onClose }) {
            const videoRef = useRef(null);
            const streamRef = useRef(null);
            const [ready, setReady] = useState(false);
            useEffect(() => {
                navigator.mediaDevices?.getUserMedia({ video: { facingMode: "user" }, audio: false })
                    .then(s => { streamRef.current = s; if (videoRef.current) { videoRef.current.srcObject = s; videoRef.current.play(); setReady(true); } })
                    .catch(() => { alert("Camera access denied or unavailable."); onClose(); });
                return () => streamRef.current?.getTracks().forEach(t => t.stop());
            }, []);
            const capture = () => {
                const v = videoRef.current;
                const cv = document.createElement("canvas");
                cv.width = v.videoWidth; cv.height = v.videoHeight;
                cv.getContext("2d").drawImage(v, 0, 0);
                onCapture(cv.toDataURL("image/jpeg", 0.92));
                streamRef.current?.getTracks().forEach(t => t.stop());
                onClose();
            };
            return (
                <div className="camera-modal">
                    <div style={{ fontSize: 11, color: "#555", letterSpacing: 2 }}>CAMERA PREVIEW</div>
                    <video ref={videoRef} playsInline muted />
                    <div className="camera-modal-actions">
                        <button className="btn btn-primary" onClick={capture} disabled={!ready} style={{ minWidth: 140 }}>üì∏ Capture</button>
                        <button className="btn btn-secondary" onClick={onClose} style={{ minWidth: 100 }}>Cancel</button>
                    </div>
                </div>
            );
        }

        // ‚îÄ‚îÄ‚îÄ Toast ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        function Toast({ msg, type, onDone }) {
            useEffect(() => { const t = setTimeout(onDone, 2700); return () => clearTimeout(t); }, []);
            return <div className={`toast ${type}`}>{msg}</div>;
        }

        // ‚îÄ‚îÄ‚îÄ App ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        function App() {
            // URL slug parsing logic
            // const getEventFromUrl = () => {
            //     const path = window.location.pathname;
            //     const slug = path.split("/").pop(); // Simple extraction, e.g. /bangalore-ultra-2025 -> bangalore-ultra-2025
            //     // Handle encoded URI components if necessary, though simple slugs are usually safe
            //     const decodedSlug = decodeURIComponent(slug);
            //     return EVENTS.find(e => e.slug === decodedSlug) || EVENTS[0];
            // };
            const getEventFromUrl = () => {
                const hash = window.location.hash.replace("#", "");
                const decodedSlug = decodeURIComponent(hash);
                return EVENTS.find(e => e.slug === decodedSlug) || EVENTS[0];
            };
            const initialEvent = getEventFromUrl();
            const [selectedEventId, setSelectedEventId] = useState(initialEvent.id);
            const [photo, setPhoto] = useState(null);
            const [selectedFrame, setSelectedFrame] = useState(null);
            const [ps, setPs] = useState(DEFAULT_PS);   // photoState
            const [editMode, setEditMode] = useState("zoom");       // "zoom" | "move"
            const [showCamera, setShowCamera] = useState(false);
            const [toast, setToast] = useState(null);
            const [isDrag, setIsDrag] = useState(false);
            const canvasRef = useRef(null);
            const fileInputRef = useRef(null);

            const event = EVENTS.find(e => e.id === selectedEventId);
            const showToast = (msg, type = "info") => setToast({ msg, type });

            const loadPhoto = (file) => {
                if (!file || !file.type.startsWith("image/")) return;
                const reader = new FileReader();
                reader.onload = e => {
                    setPhoto(e.target.result);
                    setPs(DEFAULT_PS);
                    setEditMode("move"); // immediately let them reposition
                };
                reader.readAsDataURL(file);
            };

            // Callback from StudioCanvas: accepts (offX, offY, scale?) ‚Äî any can be undefined = keep old
            const handleDrag = useCallback((ox, oy, scale) => {
                setPs(prev => ({
                    ...prev,
                    offX: ox !== undefined ? ox : prev.offX,
                    offY: oy !== undefined ? oy : prev.offY,
                    scale: scale !== undefined ? scale : prev.scale,
                }));
            }, []);

            // Nudge pad: step size in canvas pixels
            const STEP = 25;
            const nudge = (dx, dy) => setPs(p => ({ ...p, offX: p.offX + dx * STEP, offY: p.offY + dy * STEP }));

            const resetPos = () => setPs(p => ({ ...p, offX: 0, offY: 0, scale: 1.0 }));
            const resetAll = () => setPs(DEFAULT_PS);

            const download = () => {
                const cv = canvasRef.current; if (!cv) return;
                const a = document.createElement("a");
                a.download = `novarace-${event.name.replace(/\s+/g, "-")}.jpg`;
                a.href = cv.toDataURL("image/jpeg", 0.92);
                a.click();
                showToast("‚úÖ Photo saved!", "success");
            };

            const shareNative = async () => {
                const cv = canvasRef.current; if (!cv) return;
                if (!navigator.share) { download(); showToast("‚¨áÔ∏è Downloaded ‚Äì share from your gallery!", "info"); return; }

                try {
                    const dataUrl = cv.toDataURL("image/jpeg", 0.92);
                    const arr = dataUrl.split(',');
                    const mime = arr[0].match(/:(.*?);/)[1];
                    const bstr = atob(arr[1]);
                    let n = bstr.length;
                    const u8arr = new Uint8Array(n);
                    while (n--) {
                        u8arr[n] = bstr.charCodeAt(n);
                    }
                    const f = new File([u8arr], "novarace.jpg", { type: mime });

                    if (navigator.canShare && navigator.canShare({ files: [f] })) {
                        await navigator.share({
                            title: event.name,
                            text: `${event.hashTag || '#NovaRace'}`,
                            files: [f]
                        });
                        showToast("üéâ Shared!", "success");
                    } else {
                        await navigator.share({
                            title: event.name,
                            text: `${event.hashTag || '#NovaRace'}`,
                        });
                        download();
                    }
                } catch (e) {
                    console.error("Share failed", e);
                    if (e.name !== 'AbortError') {
                        download();
                    }
                }
            };

            const shareText = async (platform) => {
                const cv = canvasRef.current;
                if (!cv) return;

                const tag = event.hashTag || `#NovaRace #${event.name.replace(/\s+/g, "")}`;
                const shareMessage = `I'm running ${event.name}! üèÉ‚Äç‚ôÇÔ∏è See you at the finish line üèÖ ${tag}`;

                // Helper: convert canvas to a File object
                const getImageFile = () => new Promise((resolve) => {
                    cv.toBlob((blob) => {
                        resolve(new File([blob], "novarace.jpg", { type: "image/jpeg" }));
                    }, "image/jpeg", 0.92);
                });

                // Helper: download the image silently
                const triggerDownload = () => {
                    const a = document.createElement("a");
                    a.download = `novarace-${event.name.replace(/\s+/g, "-")}.jpg`;
                    a.href = cv.toDataURL("image/jpeg", 0.92);
                    a.click();
                };

                // ‚îÄ‚îÄ WhatsApp ‚îÄ‚îÄ
                if (platform === "whatsapp") {
                    if (navigator.share && navigator.canShare) {
                        try {
                            const file = await getImageFile();
                            if (navigator.canShare({ files: [file] })) {
                                await navigator.share({
                                    title: `I'm running ${event.name}! üèÉ`,
                                    text: shareMessage,
                                    files: [file],
                                });
                                showToast("üéâ Shared to WhatsApp!", "success");
                                return;
                            }
                        } catch (e) {
                            if (e.name === "AbortError") return;
                        }
                    }
                    // Fallback: download + open WhatsApp with text
                    triggerDownload();
                    showToast("üì∏ Photo saved! Paste it in WhatsApp.", "info");
                    setTimeout(() => {
                        window.open(
                            `https://api.whatsapp.com/send?text=${encodeURIComponent(shareMessage)}`,
                            "_blank"
                        );
                    }, 600);
                    return;
                }

                // ‚îÄ‚îÄ Instagram ‚îÄ‚îÄ
                if (platform === "instagram") {
                    if (navigator.share && navigator.canShare) {
                        try {
                            const file = await getImageFile();
                            if (navigator.canShare({ files: [file] })) {
                                await navigator.share({
                                    title: `I'm running ${event.name}! üèÉ`,
                                    text: shareMessage,
                                    files: [file],
                                });
                                showToast("üéâ Shared!", "success");
                                return;
                            }
                        } catch (e) {
                            if (e.name === "AbortError") return;
                        }
                    }
                    // Fallback
                    triggerDownload();
                    showToast("üì∏ Saved! Open Instagram ‚Üí New Post ‚Üí attach photo.", "info");
                    return;
                }

                // ‚îÄ‚îÄ Twitter / X ‚îÄ‚îÄ
                if (platform === "twitter") {
                    triggerDownload();
                    showToast("üì∏ Photo saved! Attach it to your tweet.", "info");
                    setTimeout(() => {
                        window.open(
                            `https://twitter.com/intent/tweet?text=${encodeURIComponent(shareMessage)}`,
                            "_blank"
                        );
                    }, 700);
                    return;
                }

                // ‚îÄ‚îÄ Facebook ‚îÄ‚îÄ
                if (platform === "facebook") {
                    triggerDownload();
                    showToast("üì∏ Photo saved! Attach it to your Facebook post.", "info");
                    setTimeout(() => {
                        window.open(
                            `https://www.facebook.com/sharer/sharer.php?quote=${encodeURIComponent(shareMessage)}`,
                            "_blank"
                        );
                    }, 700);
                    return;
                }
            };
            useEffect(() => {
                setSelectedFrame(event?.frames?.[0] ?? null);
                setPs(DEFAULT_PS);
            }, [selectedEventId]);

            const scaleDisplay = Math.round(ps.scale * 100);
            const ZOOM_PRESETS = [["Fit", 1.0], ["Fill", 1.3], ["2√ó", 2.0], ["3√ó", 3.0]];

            return (
                <>
                    {showCamera && (
                        <CameraModal
                            onCapture={p => { setPhoto(p); setPs(DEFAULT_PS); setEditMode("move"); }}
                            onClose={() => setShowCamera(false)}
                        />
                    )}
                    {toast && <Toast {...toast} onDone={() => setToast(null)} />}

                    <nav>
                        <div className="logo">NOVA<span>RACE</span></div>
                        <span className="badge">Frame Studio</span>
                    </nav>

                    <div className="hero">
                        <h1>MAKE IT<br /><em>YOURS</em></h1>
                        <p>Upload your photo, position it perfectly inside the frame, then share your race story.</p>
                    </div>

                    {/* Event selector (Disabled / Read-only) */}
                    <div style={{ maxWidth: 860, margin: "0 auto", padding: "0 20px" }}>
                        <div className="event-bar">
                            <label>üèÅ Selected Event</label>
                            <select
                                className="event-select"
                                value={selectedEventId}
                                disabled={true}
                                style={{ opacity: 0.7, cursor: "default" }}
                            >
                                {EVENTS.map(ev => <option key={ev.id} value={ev.id}>{ev.name} ‚Äì {ev.date}</option>)}
                            </select>
                        </div>
                    </div>

                    <div className="studio">
                        {/* ‚îÄ‚îÄ‚îÄ Left: canvas + adjustments ‚îÄ‚îÄ‚îÄ */}
                        <div>
                            <div className="canvas-panel">
                                {/* Mode toggle ‚Äî only when photo loaded */}
                                {photo && (
                                    <div className="mode-strip">
                                        <button className={`mode-btn ${editMode === "zoom" ? "active" : ""}`} onClick={() => setEditMode("zoom")}>
                                            <span className="mode-icon">üîç</span> Zoom &amp; Brightness
                                        </button>
                                        <button className={`mode-btn ${editMode === "move" ? "active" : ""}`} onClick={() => setEditMode("move")}>
                                            <span className="mode-icon">‚úã</span> Move Photo
                                        </button>
                                    </div>
                                )}

                                <StudioCanvas
                                    photo={photo}
                                    frame={selectedFrame}
                                    ps={ps}
                                    onDrag={handleDrag}
                                    editMode={editMode}
                                    canvasRef={canvasRef}
                                />

                                <div className="canvas-actions">
                                    <button className="btn btn-primary" onClick={download} disabled={!photo}>‚¨á Download</button>
                                    <button className="btn btn-secondary" onClick={shareNative} disabled={!photo}>‚Üó Share</button>
                                </div>
                            </div>

                            {/* ‚îÄ‚îÄ‚îÄ Adjustments (only when photo loaded) ‚îÄ‚îÄ‚îÄ */}
                            {photo && (
                                <div className="adj-panel">
                                    <div className="adj-head">
                                        {editMode === "zoom" ? "üîç Zoom & Brightness" : "‚úã Move & Position"}
                                        <button className="reset-link" onClick={editMode === "move" ? resetPos : resetAll}>‚Ü∫ Reset</button>
                                    </div>

                                    {/* ‚îÄ‚îÄ ZOOM mode ‚îÄ‚îÄ */}
                                    {editMode === "zoom" && (
                                        <div className="adj-body">
                                            <div className="slider-row" style={{ marginTop: 0 }}>
                                                <label>Zoom</label>
                                                <input type="range" min="0.4" max="4.0" step="0.01" value={ps.scale}
                                                    onChange={e => setPs(p => ({ ...p, scale: parseFloat(e.target.value) }))} />
                                                <span className="val">{scaleDisplay}%</span>
                                            </div>
                                            <div className="zoom-presets">
                                                {ZOOM_PRESETS.map(([lbl, v]) => (
                                                    <button key={lbl}
                                                        className={`zpre ${Math.abs(ps.scale - v) < 0.04 ? "active" : ""}`}
                                                        onClick={() => setPs(p => ({ ...p, scale: v }))}>
                                                        {lbl}
                                                    </button>
                                                ))}
                                            </div>
                                            <div className="slider-row" style={{ marginTop: 16 }}>
                                                <label>Brightness</label>
                                                <input type="range" min="50" max="160" step="1" value={ps.brightness}
                                                    onChange={e => setPs(p => ({ ...p, brightness: parseInt(e.target.value) }))} />
                                                <span className="val">{ps.brightness}%</span>
                                            </div>
                                        </div>
                                    )}

                                    {/* ‚îÄ‚îÄ MOVE mode ‚îÄ‚îÄ */}
                                    {editMode === "move" && (
                                        <div className="adj-body">
                                            <p style={{ fontSize: 13, color: "var(--nr-mid)", lineHeight: 1.6, marginBottom: 12 }}>
                                                <strong style={{ color: "var(--nr-white)" }}>Drag directly on the photo</strong> to reposition it inside the frame.
                                                On mobile, use two fingers to pinch-zoom as well.
                                            </p>

                                            {/* Live coordinates */}
                                            <div className="pos-info">
                                                <span><b>X</b> {Math.round(ps.offX)}</span>
                                                <span><b>Y</b> {Math.round(ps.offY)}</span>
                                                <span><b>Z</b> {scaleDisplay}%</span>
                                            </div>

                                            {/* Nudge arrow pad */}
                                            <div className="nudge-wrap">
                                                <div className="nudge-label">Fine nudge</div>
                                                <div className="nudge-grid">
                                                    {/* row 1 */}
                                                    <div className="nb nb-empty" />
                                                    <button className="nb" title="Up" onClick={() => nudge(0, -1)}>‚ñ≤</button>
                                                    <div className="nb nb-empty" />
                                                    {/* row 2 */}
                                                    <button className="nb" title="Left" onClick={() => nudge(-1, 0)}>‚óÄ</button>
                                                    <div className="nb-center">‚úõ</div>
                                                    <button className="nb" title="Right" onClick={() => nudge(1, 0)}>‚ñ∂</button>
                                                    {/* row 3 */}
                                                    <div className="nb nb-empty" />
                                                    <button className="nb" title="Down" onClick={() => nudge(0, 1)}>‚ñº</button>
                                                    <div className="nb nb-empty" />
                                                </div>
                                            </div>

                                            {/* Zoom also accessible in move mode */}
                                            <div className="slider-row" style={{ marginTop: 4 }}>
                                                <label>Zoom</label>
                                                <input type="range" min="0.4" max="4.0" step="0.01" value={ps.scale}
                                                    onChange={e => setPs(p => ({ ...p, scale: parseFloat(e.target.value) }))} />
                                                <span className="val">{scaleDisplay}%</span>
                                            </div>
                                            <div className="zoom-presets" style={{ marginTop: 8 }}>
                                                {ZOOM_PRESETS.map(([lbl, v]) => (
                                                    <button key={lbl}
                                                        className={`zpre ${Math.abs(ps.scale - v) < 0.04 ? "active" : ""}`}
                                                        onClick={() => setPs(p => ({ ...p, scale: v }))}>
                                                        {lbl}
                                                    </button>
                                                ))}
                                            </div>
                                        </div>
                                    )}
                                </div>
                            )}

                            {/* Social share */}
                        </div>

                        {/* ‚îÄ‚îÄ‚îÄ Sidebar ‚îÄ‚îÄ‚îÄ */}
                        <div className="sidebar">
                            {/* Upload */}
                            <div className="panel">
                                <div className="panel-header">üì∑ Your Photo</div>
                                <div className="panel-body">
                                    <div
                                        className={`upload-zone ${isDrag ? "drag-over" : ""}`}
                                        onDragOver={e => { e.preventDefault(); setIsDrag(true); }}
                                        onDragLeave={() => setIsDrag(false)}
                                        onDrop={e => { e.preventDefault(); setIsDrag(false); loadPhoto(e.dataTransfer.files[0]); }}
                                    >
                                        <input
                                            ref={fileInputRef}
                                            type="file"
                                            accept="image/*"
                                            onChange={e => loadPhoto(e.target.files[0])}
                                            onClick={(e) => (e.target.value = null)}
                                        />
                                        <div className="icon">{photo ? "‚úÖ" : "üñº"}</div>
                                        {photo
                                            ? <><strong>Photo loaded!</strong><p>Click to change</p></>
                                            : <><strong>Tap to upload</strong><p>or drag your photo here<br />JPG, PNG up to 20MB</p></>
                                        }
                                    </div>
                                    <button className="camera-btn" onClick={() => setShowCamera(true)}>
                                        üì∏ Take a selfie
                                    </button>
                                </div>
                            </div>

                            {/* Frames */}
                            <div className="panel">
                                <div className="panel-header">
                                    üñº Race Frames <span className="tag">{event.name}</span>
                                </div>
                                <div className="panel-body">
                                    {event.frames.length === 0
                                        ? <p style={{ color: "var(--nr-mid)", fontSize: 13 }}>No frames for this event yet.</p>
                                        : (
                                            <div className="frames-grid">
                                                <div className={`frame-none ${!selectedFrame ? "selected" : ""}`} onClick={() => setSelectedFrame(null)}>
                                                    No Frame
                                                </div>
                                                {event.frames.map(fr => (
                                                    <FrameThumb key={fr.id} frame={fr} selected={selectedFrame?.id === fr.id} onClick={() => setSelectedFrame(fr)} />
                                                ))}
                                            </div>
                                        )
                                    }
                                </div>
                            </div>

                            {/* Tips */}
                            <div className="panel">
                                <div className="panel-header">üí° How to Use</div>
                                <div className="panel-body" style={{ fontSize: 13, color: "var(--nr-mid)", lineHeight: 1.75 }}>
                                    <p>1Ô∏è‚É£ <strong style={{ color: "var(--nr-white)" }}>Upload</strong> your photo or take a selfie.</p><br />
                                    <p>2Ô∏è‚É£ Tap <strong style={{ color: "var(--nr-white)" }}>‚úã Move Photo</strong> then <strong style={{ color: "var(--nr-white)" }}>drag</strong> to position yourself perfectly inside the frame.</p><br />
                                    <p>3Ô∏è‚É£ Use the <strong style={{ color: "var(--nr-white)" }}>üîç Zoom</strong> tab to zoom in/out. Pinch with two fingers on mobile!</p><br />
                                    <p>4Ô∏è‚É£ Pick a <strong style={{ color: "var(--nr-orange)" }}>race frame</strong> on the right, then Download or Share.</p><br />
                                    <p>üèÖ Tag <strong style={{ color: "var(--nr-orange)" }}>{event.hashTag || "#NovaRace"}</strong> to be featured on our wall!</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </>
            );
        }

        ReactDOM.createRoot(document.getElementById("root")).render(<App />);
    </script>
</body>

</html>